[{"content":"Escape the ambush was an attempt to revisit the concept of the players being pursued as they attempt to escape. The core concept in the mission is a wave manager that will produce waves of enemies that attempt to coordinate an attack on the players.\nThe idea was to attempt to surround the players at the same time from all sides to help provide something for every player to shoot at. In essence I wanted a dynamic system to enact the role of a macro level AI commander.\nChoosing the mission area In order for this to work I needed a terrain that would offer plenty of concealment allowing troops to move into positions to stage an attack before getting caught in a firefight. I chose an area in the Anizay terrain that offers average visibility of what I estimate to be around 200-300m which is great for infantry engagements.\nPicking spawn points The next step is to determine potential locations for the enemies to spawn.\nAs shown above I have just placed game logic objects (blue squares with a flag icon). The system can pick randomly from these points.\nSetting up the AI Orders Destination: Calculating Engagement positions A simple idea is that ultimately the AI should encircle the players. A simple mathematical tool is producing a convex hull around the players. This is just a polygon line that surrounds all players (shown as a blue line in the below image). This convex hull can then be transformed to be bigger polygon of where we want to the AI to be when engaging the players. I\u0026rsquo;ll call this the \u0026ldquo;Engagement polygon\u0026rdquo; moving forwards. It is visualized above as a red line in which all points from the convex hull are pushed another 100m away from the center of the polygon.\nAttacking Forces To use this engagement polygon well on this plan we need to dispatch multiple groups (Fireteams/Squads) of AI to the player.\nArma exposes the ability to add waypoints to groups of AI which the ingame AI will follow. So to get this to work the initial piece of work is to figure out where the units should attack from.\nTo provide a challenge we need them to space out around the engagement polygon. It\u0026rsquo;s well established in military doctrine that going into a firefight as a big blob is not suitable. We\u0026rsquo;ll aim to spread out the troops across a line formation. As shown below 4 groups of 5 soldiers each in line formation:\nTo ease things for the AI I also backplaced waypoints for each group behind the final engagement waypoints. As this forces the AI to already be working towards the direction they should be facing to engage. In addition the spacing between the groups waypoints will depend on the group to ensure there is enough room for all the soliders to be in line without groups overlapping.\nThere is a potential synchronization issue where some groups may move to their waypoints before other groups (see below where the right most group is closer to its engagement point than the others). This can be solved by having some code monitor the groups and ordering groups that are ahead of others to slow down by walking whilst the other groups catching up moving faster by jogging. Which eventually balances itself out.\nScaling up To spice things up for the players we want to send multiple groups after the players at the same time. The groups claim a part of the perimeter of the engagement polygon and prevent other groups from it, resulting in a nice encirclement of final waypoints around the players as visualized below: Now finally as a mission multiple waves are sent to the players, and plans are rebalanced as the players move. Now in practice \u0026ldquo;No plan survives first contact with the enemy\u0026rdquo;. The players keep moving and the AI lose units. Both of these present their own issues but could be countered in the future. But for the time being the coordinated approach seemed cool enough to release as a mission.\nAppendix Videos R3 Recordings Some selected R3 recordings of playthroughs at 1Tac sessions of the mission:\n 12th Jan 2019 - 13 Players 5th March 2019 - 18 Players 30th August 2019 - 19 players  ","permalink":"https://sniperhid.github.io/posts/escape-the-ambush/","summary":"Escape the ambush was an attempt to revisit the concept of the players being pursued as they attempt to escape. The core concept in the mission is a wave manager that will produce waves of enemies that attempt to coordinate an attack on the players.\nThe idea was to attempt to surround the players at the same time from all sides to help provide something for every player to shoot at.","title":"Escape the Ambush - Case study of coordinated AI attack"},{"content":"Mission Premise The player objective is to escape to the exfil marker on the south side of the map whilst being pursued by soviet forces.\nEnemy design As always with my Arma AI mission making experiments I wanted to focus on the macro/high level planning of AI movements. The key mechanic I wanted to utilize in this mission was to have a constant stream of enemies appearing to challenge player movements using helicopters.\nThe simple idea for driving the AI strategy is to every few minutes to dispatch another wave of roughly 4 mi-8 helicopters filled with troops.\nStep 1) Identifying helicopter Landzones (LZ) One of the key tasks for the AI will be selecting potential landing zones (LZ) for pilots. The first step is to collect a list potential candidates.\nThese LZs need to be relatively flat areas for the AI to be able to land. They are not capable of landing on slopes like skilled players can. They also big enough to land Mi-8 helicopters.\nAutomatic LZ Search I initially explored algorithmic approaches to find suitable LZs.\nI sampled points across the mission area and compared the heights against neighbouring samples to identify areas with little elevation change. The result of which looking like this. Red dots were suitable landing positions.\nManual LZ Placement It quickly dawned on me that whilst I could spend more time tailoring the algorithm to identify better candidates I could rapidly manually select LZs in Arma\u0026rsquo;s 3D editor. These would naturally be high quality and could be reasonably spaced out. In addition avoiding the computational cost of searching.\nThis was achieved by placing invisible helipad objects in the game across the playable area, (these also encourage Arma AI to land on them). T Step 2) Dynamically Choosing Landing zones We now have a list of LZ candidates. We now to choose appropriate LZs to dispatch helicopters to dismount troops at. The question we now need to address is which LZs do we send the helicopters to. We need to rank these LZs by calculating a score known as a weight for each candidate using a weighting function.\nOne of the great things about this being a game is we know exactly where the players are and we know where they are going. This makes it relatively straightforward to select a suitable weighting algorithm. I did try a few but eventually settled on one.\nWeighting Algorithm It became obvious to me that they were three things I could quantify that would be useful to know. Most of these revolve around the average player position (the mean position of all players). As well as the final objective.\nThese three factors are the distance from the landing zone to:\n A) To the player goal - We want to favour LZes closer to the finish. B) Average player position - We want to favour LZes nearer the players for more engaging gameplay. C) Line connecting the average player zone to the goal - We want to favour LZs that give the AI a better chance at intercepting the players.  These three values can be calculated and combined into a single weight function. After some empirical investigation I ended up using the following weighting function: LZ Weight = C + ( B / 1.65) + ( A / 5 )\nOne of the great things with this approach is that it\u0026rsquo;s really easy to visualize the rankings.\nIn the following test visualizations the assumed average player position is using the HQ marker. The red/orange dots are the landing zones. The brighter the red the higher the prospective LZ ranks. I have presented three images to show the difference in scores as the players move: In the above you can see the selected LZs are closer to the top of the image (North), as the HQ marker moves in the next image, the rankings change. And finally below we can see the higher ranked LZs as the players get close to the exfiltration objective. Distribution Selection Now that we have each landing zone with a score, we can sort them by the weight descending. I also wanted to add some randomness to spice things up. I opted for a random gaussian distribution function as provided through SQF\u0026rsquo;s random command. I also filtered the variable _positions (containing the list of sorted candidate LZs) to the top 40 LZes.\nfloor (random [0, 0, count (_positions)]) Here is a plot showing the probability of each index being selected from the weight sorted list of LZ candidates. Editorial Note: I was aiming for a less steep gradient but did not verify when writing the code but wish to preserve historical accuracy.\nPolishing Now that we have a system for selecting LZs which this post focuses on. To complete the picture I created some additional pieces of code for:\n Creating helicopters loaded with AI troops that would then creates waypoints for the AI units to follow to land at the LZ (Handled by Arma 3\u0026rsquo;s waypoint system). Code for managing ground troops. This was quite simple and would simply order AI units towards the players.  I also added a few ambient patrols and some initial para-dropped troops to add some visual diversity.\nAppendix R3 data These are some R3 playbacks from my Arma community (1Tac) playing the mission\n 9th Jan 2018 - 19 players 14th Jan 2018 - 26 players 3rd Jan 2020 - 16 players 4th July 2020 - 20 players 14 Nov 2020 - 16 players  ","permalink":"https://sniperhid.github.io/posts/escape-the-bear/","summary":"Mission Premise The player objective is to escape to the exfil marker on the south side of the map whilst being pursued by soviet forces.\nEnemy design As always with my Arma AI mission making experiments I wanted to focus on the macro/high level planning of AI movements. The key mechanic I wanted to utilize in this mission was to have a constant stream of enemies appearing to challenge player movements using helicopters.","title":"Escape The Bear - Case study of Priorization"},{"content":"The first version of aussie holdout appeared in 2015, and has served as a hotbed for a few ideas. In 2018 I worked on upgrading it from the 2D to 3D editor and doing more experimentation.\nMission Premise The premise of this mission is for the players to hold a fixed position while waves of AI attack.\nThe enemy will use a combination of infantry forces and armoured vehicles with autocannons (e.g. BMP-2).\nAI Orders A key area I wanted to explore in this mission is the ability for the AI to figure out what paths to take to advance to the defensive location. My scripts needed to handle the spawning and issuing orders (via waypoints) to the AI.\nAI spawn points. An easy way to determine spawn points is to place game logics and give them a name. These can then be identified and used easily in code. These have the added advantage of being able to rapidly moved around in the mission editor.\nThe original version of the mission was made Arma 3\u0026rsquo;s 2D mission editor which would allow assigning waypoints to game logics. These were then copied to spawned groups, giving the mission maker plenty of control (via custom mission code).\nUnfortunately the 3D editor removed the ability to assign waypoints to game logics, and so a new approach was required for assigning waypoints.\nCalculating AI movement orders Simple movement An easy next step is to either simply have the AI moving directly from the spawnpoint to the defense position by creating a waypoint on the defence objective.\nHowever this can lead to foolish choices such as walking across large open exposed areas where they can be easily picked off on their approach.\nLine of Sight Grid A simple idea when attacking is to get as close as possible without the enemy being able to see you. I decided to apply this principle into action. Something we can get a reasonable approximation for is the visibility of a position from another by doing some intersection testing, checking if either terrain or objects block the visibility from two positions.\n#TODO: Show line(?)\nIf we do this across the area by using a grid of points to approximate the area. We can produce a visualization like the following:\nThis shows the visibility to the North of the defense area with Red areas being those that can be easily seen from the castle. For example the coast to the east (right side) offers a sheltered approach as does river to the west (left of the castle). An approach minimizing visibility would minimize exposure to the red areas.\nCreating a path The A* Star algorithm is a well known algorithm for efficiently finding paths. This was implemented to search through the generated line of sight (LOS) grid. Then running through this a process of reducing this into points that form straight lines we get the following image:\nThis shows points along various paths from the gamelogics to the objective. Each path uses a different colour of dots to represent the path. For example the right most path is using red-brown dots.\nThis is enough to automatically create waypoints for advancing elements.\nDiversifying the attack It\u0026rsquo;s not just enough for an attack to have soldiers heading straight forward to an objective. Suppressive fire is extremely useful. So we want to have some of the attacking fire used for providing suppressive fire while others are advancing (covering fire).\nTo achieve this we need to identify positions for the base of fire elements to go to. Whilst this can be done automatically and is something to be explored in the future. I opted for the quicker method of preplacing gamelogics for base of fire positions (identified by naming convention e.g. infbof_ or veh_bof) as shown below:\nI separated the vehicle and infantry bof positions as some are inappropriate for infantry and vehicles and vice versa. For example vehicle autocannons are capable for being effective at great ranges 800m+. While infantry small arms rifles typically have a shorter effective range of 300-500m. Vehicles also need suitable approaches to the base of fire and not navigate all types of terrain.\nIn general a good covering position should have good visibility of the objective.\nI then also wrote code for base of fire elements to forcefully fire upon the objective periodically from their position.\nThe result Now we combine this all together and ingame we\u0026rsquo;ll see something like the following orders assigned to the AI.\nExtra Elements To add some icing to the cake I threw in some smoke artillery shells to land on the defense objective to obscure defender vision and added in a helicopter or two to circle the defense objective.\nAppendix R3 playbacks  14th July 2018 - 41 players  ","permalink":"https://sniperhid.github.io/posts/defence-pathfinding/","summary":"The first version of aussie holdout appeared in 2015, and has served as a hotbed for a few ideas. In 2018 I worked on upgrading it from the 2D to 3D editor and doing more experimentation.\nMission Premise The premise of this mission is for the players to hold a fixed position while waves of AI attack.\nThe enemy will use a combination of infantry forces and armoured vehicles with autocannons (e.","title":"Aussie Holdout - Case study of pathfinding"},{"content":"Arma 3\u0026rsquo;s default AI typically do not coordinate beyond a group level and have limited coordination inside a group. This leads to sub-optimal performance in firefights and more unrealistic behaviour from AI. As it seems they tend to take foolish actions. This motivated me to attempt to improve AI behaviour with some realistic tactical coordination.\nNow to borrow some military theory. A significant change in military tactics was the discovery and adaptation of firearms. Which led to fire and maneuver tactics. These are fairly central to coordinated realistic coordinated behaviour. The general principle is that elements/units receiving fire are less effective and typically become suppressed. The next key idea is that advancing elements can be supported by other elements offer covering fire by engaging any enemy forces, hopefully preventing enemy forces from retaliating whilst receiving fire.\nI settled on opting to attempt to implement Bounding overwatch. Bounding overwatch is where an element advances (Bounding Element) and another provides fire support (Overwatching Element).\nI carried out two distinct efforts on this. Firstly an earlier one in 2015 focusing on intergroup bounding which one AI group would bound and the other would overwatch. Then later in 2018 I decided to try and get this working inside a group, which half the group doing each task.\nIntergroup Bounding Take Attempt from Aussie Hold out\n// Bounding OVerwatch assault! // [group1, group2, targetPos] execVM \u0026quot;bounding.sqf\u0026quot;; private [\u0026quot;_group1\u0026quot; ,\u0026quot;_group2\u0026quot;, \u0026quot;_targetPos\u0026quot;, \u0026quot;_centerPos\u0026quot; ,\u0026quot;_direction\u0026quot;, \u0026quot;_grpPos1\u0026quot;, \u0026quot;_grpPos2\u0026quot;,\u0026quot;_startPos\u0026quot;, \u0026quot;_tempPos\u0026quot;, \u0026quot;_boundDist\u0026quot;, \u0026quot;_grpDist\u0026quot;, \u0026quot;_wp\u0026quot;]; _group1 = _this select 0;//group1; _group2 = _this select 1;//group2; _targetPos = _this select 2; //getMarkerPos \u0026quot;aiAttackMarker\u0026quot;; _grpPos1 = []; if (count (waypoints _group1) \u0026gt; 0) then { _grpPos1 =(getWPPos ((waypoints _group1) select (count waypoints _group1)-1)); } else { _grpPos1 = getPos (leader _group1); }; _grpPos2 = []; if (count (waypoints _group2) \u0026gt; 0) then { _grpPos2 = (getWPPos ((waypoints _group2) select (count waypoints _group2)-1)); } else { _grpPos2 = getPos(leader _group2); }; _centerPos = (_grpPos1 vectorAdd _grpPos2) vectorMultiply 0.5; _direction = [_centerPos,_targetPos] call BIS_fnc_dirTo; _boundDist = 50; _grpDist = _grpPos1 distance _grpPos2; _startPos = _grpPos1; _tempPos = [0,0,0]; _group1 setVariable [\u0026quot;bounding_buddy\u0026quot;,_group2]; _group2 setVariable [\u0026quot;bounding_buddy\u0026quot;,_group1]; { _x disableAI \u0026quot;FSM\u0026quot;;} forEach (units _group1); { _x disableAI \u0026quot;FSM\u0026quot;;} forEach (units _group2); _group1 allowFleeing 0; _group2 allowFleeing 0; // // bounding to overwatch. _wp = _group1 addWaypoint [_startPos,0]; _wp setWaypointBehaviour \u0026quot;AWARE\u0026quot;; _wp setWaypointStatements [\u0026quot;true\u0026quot;, \u0026quot;(group this) call fn_startOverwatching;\u0026quot;]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; _wp = _group1 addWaypoint [_startPos,0]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; _wp setWaypointStatements [\u0026quot;(group this) getVariable ['att_okayToBound',false]\u0026quot;,\u0026quot;(group this) setVariable ['att_okayToBound',false]; (group this) call fn_startBounding; \u0026quot;]; _wp = _group2 addWaypoint [_grpPos2,0]; _wp setWaypointStatements [\u0026quot;true\u0026quot;,\u0026quot;(group this) setVariable ['att_okayToBound',false]; (group this) call fn_startBounding; \u0026quot;]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; /* Problems: Group leader is unconscious, the group stops moving. - AI when starting overwatch dont lay down a large amount of fire (unless they seem have a viabletarget?) - AI planning,cover routines take over. */ while {_startPos distance _targetPos \u0026gt; 180} do { _startPos = [_startPos,_boundDist,_direction] call fn_trans_pos; _tempPos = [_startPos,_grpDist,_direction+90] call fn_trans_pos; // Overwatch _wp = _group2 addWaypoint [_tempPos,0]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; _wp setWaypointBehaviour \u0026quot;AWARE\u0026quot;; _wp setWaypointStatements [\u0026quot;true\u0026quot;, \u0026quot;(group this) call fn_startOverwatching; ((group this) getVariable 'bounding_buddy') setVariable ['att_okayToBound',true];\u0026quot;]; // Bounding _wp = _group2 addWaypoint [_tempPos,0]; _wp setWaypointStatements [\u0026quot;(group this) getVariable ['att_okayToBound',false]\u0026quot;,\u0026quot;(group this) setVariable ['att_okayToBound',false]; (group this) call fn_startBounding; \u0026quot;]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; //_wp setWaypointTimeout [1,3,4]; // Overwatch _wp = _group1 addWaypoint [_startPos,0]; _wp setWaypointBehaviour \u0026quot;AWARE\u0026quot;; _wp setWaypointStatements [\u0026quot;true\u0026quot;, \u0026quot;(group this) call fn_startOverwatching; ((group this) getVariable 'bounding_buddy') setVariable ['att_okayToBound',true];\u0026quot;]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; // Bounding _wp = _group1 addWaypoint [_startPos,0]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;MOVE\u0026quot;; _wp setWaypointStatements [\u0026quot;(group this) getVariable ['att_okayToBound',false]\u0026quot;,\u0026quot; (group this) setVariable ['att_okayToBound',false]; (group this) call fn_startBounding;\u0026quot;]; //_wp setWaypointTimeout [1,3,4]; sleep 0.5; // Pace out the creation of the waypoints. }; //Commit groups to final. { ((waypoints _group1) select (count (waypoints _group1) - 1)) setWaypointStatements [\u0026quot;true\u0026quot;,\u0026quot;(group this) call fn_startAssault\u0026quot;]; ((waypoints _group2) select (count (waypoints _group2) - 1)) setWaypointStatements [\u0026quot;true\u0026quot;,\u0026quot;(group this) call fn_startAssault\u0026quot;]; _wp = _x addWaypoint [_targetPos,50]; _wp setWaypointCompletionRadius 1; _wp setWaypointType \u0026quot;SAD\u0026quot;; _wp setWaypointCombatMode \u0026quot;RED\u0026quot;; _wp setWaypointBehaviour \u0026quot;COMBAT\u0026quot;; } forEach [_group1,_group2]; Intragroup Bounding Scripted Waypoint Arma 3 offers the ability to create custom scripted waypoints via its setWaypointScript SQF command. This allows you to attach code.\nIn action   Summary One of the key takeways that to accomplish this in SQF is unfortunately expense there is a lot of code that needs to run to monitor the group and issue actions. This may work well for small numbers of AI but would efficiently scale to big numbers. Hopefully this is something addressed by AI in a future military simulation game.\n","permalink":"https://sniperhid.github.io/posts/bounding-overwatch/","summary":"Arma 3\u0026rsquo;s default AI typically do not coordinate beyond a group level and have limited coordination inside a group. This leads to sub-optimal performance in firefights and more unrealistic behaviour from AI. As it seems they tend to take foolish actions. This motivated me to attempt to improve AI behaviour with some realistic tactical coordination.\nNow to borrow some military theory. A significant change in military tactics was the discovery and adaptation of firearms.","title":"AI Bounding Overwatch"},{"content":"Overview Dynamic Squad Mission (DSM) was my first foray into making a code driven mission. I created it at the beginning of 2016. The general idea was to write scripts to create AI units and manage their tactics. To keep things simple in this initial attempt the initial idea was to have some AI spawn in buildings that the players would clear.\nIt ended up being code that did wrap some pre-existing tools for managing aspects of the AI which I\u0026rsquo;d like to spread awareness of but also had its own code.\nFirst Step: Selecting a play location So to have a play area we need an objective for the AI side to defend. I opted to have preplaced positions using markers and then pick one randomly. Below is an example of the some markers that have been placed in the mission editor.\nEach of these locations has at least one building within 125m of the selected marker. At mission start one of these would be randomly selected as the objective for that playthrough.\nSecond Step: Creating the AI units Now we have a location we need to create AI with an initial distribution of AI tasks. I wanted to split the AI across three tasks:\n Garrison on Objective- Some AI would be occupying buildings to defend Patrolling AI - Some AI would walk around patrolling the area, perhaps with a bit of luck running into any approaching force Guarding AI - Having some AI setup in random positions.  Creating a Garrison This is fairly simple and just involves collecting all the buildings within 125m radius. Arma 3 offers a script command for doing this, using the base class of a few building types to ensure these are buildings.\nprivate _buildings = nearestObjects [_centerPos, [\u0026quot;Fortress\u0026quot;, \u0026quot;House\u0026quot;, \u0026quot;House_Small\u0026quot;, \u0026quot;Ruins_F\u0026quot;, \u0026quot;BagBunker_base_F\u0026quot;, \u0026quot;Stall_base_F\u0026quot;,\u0026quot; Shelter_base_F\u0026quot;], 125]; The arma 3 engine also enables buildings to be configured with several positions inside the building where units can stand via the buildingPos command.\nVisualized the building positions look like this (visualized courtesy of TMF\u0026rsquo;s Garrison tool): And if we spawn an AI unit in ever place it would look something like this: Creating a Patrolling AI The next step is adding some AI to patrol the area. There is a scripted function that BI produced called BIS_fnc_patrol and the CBA addon add an improved version called CBA_fnc_patrol. Both of these creates a sequence of randomly placed movement waypoints within a radius of a center point - followed by a cycle waypoint so the AI repeat through all movement waypoints.\nAs each point is generated randomly these patrols can take on any shape, here is an example:\nGuard Waypoint Arma 3 also offers another useful waypoint type called guard. This is pretty powerful and in our context we use it to have the designated AI group remaining at the guard waypoint, but if any other groups get into combat they will signal to groups in guard mode to come and reinforce them.\nInitial State Example Now that we have the ability to create AI across several tasks. We need to distribute the AI units across these tasks. Firstly I wrote a bit of code that would scale the AI unit numbers based on the number of players.\nprivate _aiCount = round ((5 + (_playerCount * AI_RATIO)) min 120); // Ensure maximum of 120 AI The AI_RATIO is a mission parameter with a default of 2.2. So for 10 players this would result in creating 27 AI units.\nThese units would then be distributed across the tasks with roughly a quarter in garrison, a third guarding and any leftovers patrolling. Below is an example of 27 units distributed across the three tasks.\nManaging the AI mid-mission The AI now have some initial tasks but in a real situation a commander would alter the tasks of units under his command to adapt to changing conditions. An example being that if an attacking force was detected arriving from a single direction, it might be worth having units that are not being utilized to assist those that will soon be engaged in combat.\nI wrote a basic manager that would monitor all AI groups to see if they were aware of any enemy units. If they became aware of enemies they would call for reinforcements from other groups that were patrolling or otherwise idle. This was easily achieved by maintaining a list of groups on patrol and then removing their existing waypoints and giving them new waypoints to instruct them to moving towards known enemies. After the enemies are eliminated a new sequence of patrol waypoints would be created.\nAnother key behaviour to instil in the AI and also to ensure that a mission would not draw out is that if the units garrisoning the objective start to take too many casualties all units would fallback to the objective.\nThis leads to some pretty compelling gameplay where you can be flanked by AI whilst you are in the middle of a firefight.\nFuture Plans As I write this post in 2021 (5 years later) the core of DSM was rewritten by Head into a new mission called Static Platoon Operation (SPO) that expands and rewrites on the initial code.\n","permalink":"https://sniperhid.github.io/posts/dynamic-squad-mission/","summary":"Overview Dynamic Squad Mission (DSM) was my first foray into making a code driven mission. I created it at the beginning of 2016. The general idea was to write scripts to create AI units and manage their tactics. To keep things simple in this initial attempt the initial idea was to have some AI spawn in buildings that the players would clear.\nIt ended up being code that did wrap some pre-existing tools for managing aspects of the AI which I\u0026rsquo;d like to spread awareness of but also had its own code.","title":"Dynamic Squad Mission - Initial look into dynamic scenarios"}]